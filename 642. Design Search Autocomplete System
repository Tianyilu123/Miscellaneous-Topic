
import java.util.Map.Entry;
class AutocompleteSystem {
        private TrieNode root;
        private TrieNode curNode;
        private StringBuilder path;
        private HashMap<String, Integer> countBook;

    public AutocompleteSystem(String[] sentences, int[] times) {
            if(sentences == null || times == null || sentences.length != times.length) 
                throw new IllegalArgumentException();
            
            root = new TrieNode('\0');
            curNode = root;
            path = new StringBuilder();
            countBook = new HashMap<>();
            int len = sentences.length;
            
            for(int i=0; i<len; i++) {
                countBook.put(sentences[i], times[i]);
                insert(sentences[i], times[i]);
            }
        }
    
    public List<String> input(char c) {
        if(c == '#') {
                curNode = root;
                String insertMe = path.toString();
                Integer count = countBook.get(insertMe);
                if(count == null) {
                    countBook.put(insertMe, 1);
                } else {
                    countBook.put(insertMe, count+1);
                }
                insert(insertMe, countBook.get(insertMe));
                path = new StringBuilder();
                return new ArrayList<>();
            }
            path.append(c);
            if(curNode == null) {
                return new ArrayList<>();
            }
            int index = (c>='a' && c<='z') ? (c-'a') : 26;
            curNode = curNode.nexts[index];
            if(curNode == null) {
                return new ArrayList<>();
            }
            return getTop3String(curNode.countMap);
    }
        
        private void insert(String sentences, int times) {
            TrieNode cur = root;
            for(char ch : sentences.toCharArray()) {
                int index = (ch>='a' && ch<='z') ? (ch-'a') : 26;
                if(cur.nexts[index] == null) {
                    cur.nexts[index] = new TrieNode(ch);
                }
                TrieNode next = cur.nexts[index];
                next.countMap.put(sentences, times);
                List<Pair> top3 = getTop3Pair(next.countMap);
                next.countMap.clear();
                for(Pair p : top3) {
                    next.countMap.put(p.str, p.count);
                }
                cur = next;
            }
            cur.isLeaf = true;
        }
        
        private List<String> getTop3String(HashMap<String, Integer> countMap) {
            return getTop3Pair(countMap)
                .stream()
                .map(p -> p.str)
                .collect(Collectors.toList());
        }
        
        private List<Pair> getTop3Pair(HashMap<String, Integer> countMap) {
            PriorityQueue<Pair> maxHeap = new PriorityQueue<>((a,b)-> 
                                            (a.count == b.count ? a.str.compareTo(b.str) 
                                           : b.count-a.count));
            for(Entry<String, Integer> e : countMap.entrySet()) {
                maxHeap.offer(new Pair(e.getKey(), e.getValue()));
            }
            List<Pair> ret = new ArrayList<>();
            for(int i=0; i<3 && !maxHeap.isEmpty(); i++) {
                ret.add(maxHeap.poll());
            }
            return ret;
        }
        
        class TrieNode {
            public char ch;
            public TrieNode[] nexts;
            public HashMap<String, Integer> countMap;
            public boolean isLeaf;
            public TrieNode(char ch) {
                this.ch = ch;
                nexts = new TrieNode[27];
                this.isLeaf = false;
                countMap = new HashMap<>(3);
            }
        }
        
        public class Pair {
            public String str;
            public int count;
            public Pair(String str, int count) {
                this.str = str;
                this.count = count;
            }
        }
    }
